#' Joint DVI search
#'
#' _Note_: This is a redesign of [jointDVI()], with narrower scope (no
#' preprocessing steps) and more informative output. It now includes conditional
#' LRs for each pairing, presented both in PM-centric and AM-centric format.
#'
#' @param dvi A `dviData` object, typically created with [dviData()].
#' @param threshold A nonnegative number; threshold for `GLR` in `Summary`.
#' @param assignments A data frame containing the assignments to be considered
#'   in the joint analysis. By default, this is automatically generated by
#'   taking all combinations from `dvi$pairings`.
#' @param disableMutations Either TRUE, FALSE (default) or NA. If NA, mutation
#'   modelling is applied only in families where the reference data are
#'   incompatible with the pedigree unless at least one mutation has occurred.
#' @param ignoreSex A logical, only relevant if `dvi$pairings` is NULL, so that
#'   candidate pairings have to be generated.
#' @param maxAssign A positive integer. If the number of assignments going into
#'   the joint calculation exceeds this, the function will abort with an
#'   informative error message. Default: 1e5.
#' @param numCores An integer; the number of cores used in parallelisation.
#'   Default: 1.
#' @param cutoff A number; if non-negative, the output table is restricted to
#'   LRs equal to or exceeding this value.
#' @param verbose A logical.
#'
#' @return A list of data frame:
#'   * `joint`: TODO
#'   * `GLRmatrix`: A matrix whose entry (i,j) is the generalised LR for the
#'     pairing `V_i = M_j`, based on the joint likelihoods.
#'   * `summary`: A summary of the pairings for which `GLR > threshold`.
#'
#' @examples
#' dviJoint(example2)
#'
#' @importFrom utils setTxtProgressBar txtProgressBar
#' @importFrom parallel makeCluster stopCluster detectCores parLapply
#'   clusterEvalQ clusterExport
#'
#' @export
dviJoint = function(dvi, threshold = 10000, assignments = NULL, ignoreSex = FALSE, disableMutations = FALSE, 
                    maxAssign = 1e5, numCores = 1, cutoff = 0, verbose = TRUE) {
  
  st = Sys.time()
  
  # Ensure proper dviData object
  dvi = consolidateDVI(dvi)
  
  if(verbose)
    print.dviData(dvi)
  
  ### Mutation disabling
  if(any(allowsMutations(dvi$am))) {
    am = dvi$am
    
    if(verbose) 
      cat("\nMutation modelling:\n")
    
    if(isTRUE(disableMutations)) {
      if(verbose) cat(" Disabling mutations in all families\n")
      disableFams = seq_along(am)
    }
    else if(identical(disableMutations, NA)) {
      am.nomut = setMutmod(am, model = NULL)
      badFams = vapply(am.nomut, loglikTotal, FUN.VALUE = 1) == -Inf
      if(verbose) {
        if(any(badFams)) 
          cat("", sum(badFams), "inconsistent families:", trunc(which(badFams)), "\n")
        cat("", sum(!badFams), "consistent families. Disabling mutations in these\n")
      }
      disableFams = which(!badFams)
    }
    else disableFams = NULL
  
    if(length(disableFams)) {
      am[disableFams] = setMutmod(am[disableFams], model = NULL)
    }
    
    # Update DVI object
    dvi$am = am
  }
  
  pm = dvi$pm 
  am = dvi$am
  vics = names(pm)
  missing = dvi$missing
  pairings = dvi$pairings %||% generatePairings(dvi, ignoreSex = ignoreSex)
  
  if(is.null(assignments)) {
    if(verbose) cat("\nCalculating pairing combinations\n")
    # Expand pairings to assignment data frame
    assignments = expand.grid.nodup(pairings, max = maxAssign)
  }
  else {
    if(verbose) cat("\nChecking supplied pairing combinations\n")
    if(!setequal(names(assignments), vics))
      stop2("Names of `assignments` do not match `pm` names")
    assignments = assignments[vics]
  }
  
  nAss = nrow(assignments)
  if(nAss == 0)
    stop2("No possible solutions!")
  if(verbose)
    cat("Assignments to consider in the joint analysis:", nAss, "\n\n")
  
  # Convert to list; more handy below
  assignmentList = lapply(1:nAss, function(i) as.character(assignments[i, ]))
  
  # Initial loglikelihoods
  logliks.PM = vapply(pm, loglikTotal, FUN.VALUE = 1)
  logliks.AM = vapply(am, loglikTotal, FUN.VALUE = 1)
  
  loglik0 = sum(logliks.PM) + sum(logliks.AM)
  if(loglik0 == -Inf)
    stop2("Impossible initial data: AM component ", which(logliks.AM == -Inf))
  
  # Parallelise?
  if(is.na(numCores))
    numCores = max(detectCores() - 1, 1)

  cl = NULL
  if(numCores > 1) {
    cl = makeCluster(numCores)
    on.exit(stopCluster(cl))

    if(verbose) 
      cat("Using", numCores, "cores\n")
    
    cl = makeCluster(numCores)
    on.exit(stopCluster(cl))
    clusterEvalQ(cl, library(dvir))
    clusterExport(cl, "loglikAssign", envir = environment())
  }
   
  # Loop through assignments
  loglik = pblapply(assignmentList, cl = cl, FUN = function(a) 
    loglikAssign(pm, am, vics, a, loglik0, logliks.PM, logliks.AM))
  
  loglik = unlist(loglik, use.names = FALSE)
  
  # Sort in decreasing likelihood, break ties with assignments (alphabetically)
  g = assignments
  g[g == "*"] = NA
  g = cbind(ll = -loglik, g)
  ORD = do.call(order, g)

  assignments = assignments[ORD, , drop = FALSE]
  rownames(assignments) = NULL
  
  # Sorted (joint) logliks and LR
  loglik = loglik[ORD]
  LR = exp(loglik - loglik0) # joint LR
  posterior = LR/sum(LR) # assuming flat prior
  
  # Conditional LRs
  #condLR_PM = conditionalLR(assignments, jointLR = LR)
  #condLR_AM = conditionalLR(assignmentsAM, jointLR = LR)
  
  # Collect joint results, including both PM and AM centric assignment tables
  joint = cbind(assignments, loglik = loglik, LR = LR, posterior = posterior, 
                swapRoles(assignments))
  
  # Generalised LR matrix
  G = matrix(NA_real_, nrow = length(vics), ncol = length(missing), 
             dimnames = list(vics, missing))
  
  # Fill matrix row-wise
  for (v in vics) {
    miss = pairings[[v]]  
    # NB: don't remove "*" yet. The following assumes that `miss` contains precisely all elements present in 
    
    # If single element, GLM is not defined
    if(length(miss) == 1)
      next
    
    # Index of 1st row with v = m, for each m in miss
    idxNumer = match(miss, assignments[[v]])
    
    # Index of 1st row with v != m: either 1 or the 2nd lowest element of idxNumer
    idxDenom = ifelse(idxNumer > 1, 1, min(idxNumer[idxNumer > 1]))
    
    glr = exp(loglik[idxNumer] - loglik[idxDenom])
    
    # Insert in matrix (excluding star if present)
    star = miss == "*"
    G[v, miss[!star]] = glr[!star]
  }
  
  # Indices of matches exceeding GLR threshold
  highGLR = which(G > threshold, arr.ind = TRUE)
  if(nrow(highGLR)) {
    vicsG = vics[highGLR[, 1]]
    missG = missing[highGLR[, 2]]
    summ = data.frame(
      Family = getFamily(dvi, missG),
      Missing = missG, 
      Sample = vicsG, 
      GLR = G[highGLR],
      Comment = paste("Joint:", paste0(missing, collapse = ",")))
  }
  else {
    summ = NULL
  }
  
  if(verbose)
    cat("Time used:", format(Sys.time() - st, digits = 3), "\n")
  
  list(joint = joint, GLRmatrix = G, summary = summ)
}



# Auxiliary function used in `dviJoint()`
conditionalLR = function(assignments, jointLR) {
  # Row number of reduced assignments (to be used in denominators)
  idx = denominatorRow(assignments)
  
  # Conditional LRs
  cLR = jointLR / jointLR[idx]
  dim(cLR) = dim(assignments)
  colnames(cLR) = paste0("cLR_", names(assignments))
  
  as.data.frame(cLR)
}



#' Row number of denominator assignment
#'
#' This is an auxiliary function used in the calculation of conditional LRs from
#' a table of joint LRs. For each assignment vector (a row in the table) and
#' each nontrivial pairing `V = M` within that assignment, it find the row
#' containing the assignment to be used in the denominator, i.e., where `V = M`
#' is replaced with the nonpairing `V = *`. Table entries of `*`, or where
#' the denominator does not occur, gives NA.
#'
#' @param assignments A data frame.
#'
#' @return A matrix of the same dim as `assignments`.
#'
#' @examples
#' \dontrun{
#' a = rbind(c(V1 = "M1", V2 = "M2", V3 = "M3"),
#'           c(V1 = "M1", V2 = "M2", V3 = "*"),
#'           c(V1 = "*",  V2 = "M2", V3 = "*"))
#' a
#' dvir:::denominatorRow(a)
#' }
#' @keywords internal
denominatorRow = function(assignments) {
  
  # Convert to matrix (faster)
  amat = as.matrix(assignments)
  nass = nrow(amat)
  nc = ncol(amat)
  
  # Create output matrix
  res = matrix(NA_integer_, nrow = nass, ncol = nc)
  
  # The array gymnastics to follow is more convenient when we transpose
  aTrans = t.default(amat)
  
  # Array of copies of aTrans, one layer for each assignment
  arr = rep(aTrans, nass)
  dim(arr) = c(nc, nass, nass)  # arr[,,1] = arr[,,2] = ...
  
  # Similar array, but where layer i contains copies of assignment i 
  aLayers = lapply(1:nass, function(i) rep(aTrans[,i], nass)) |> 
    unlist(recursive = FALSE, use.names = FALSE)
  dim(aLayers) = dim(arr)
  
  # Detect all changes ...
  diff = arr != aLayers
  
  # ... with exactly 1 diff in column
  diff1 = diff & rep(colSums(diff, 2) == 1, each = nc)
  
  # ... and where the change is into *
  toStar = diff1 & arr == "*"
  
  # Indices of T's
  idx = which(toStar, arr.ind = TRUE)
  
  # Interpretation of columns of idx (i.e., dim order in toStar)
  # 1 : column of amat
  # 2 : row of amat with a change to * in this col (This is what we want!)
  # 3 : row of amat whose assignment we are comparing with 
  # Hence:
  res[idx[, c(3,1), drop = FALSE]] = idx[,2]
  
  res
}


#' Swap centricity of an assignment table
#'
#' This function switches the roles of victims and missing persons in a table of
#' assignments, from PM-centric (victims as column names) to AM-centric (missing
#' persons as column names), and _vice versa_. In both version, each row
#' describes the same assignment vector.
#'
#' @param df A data frame. Each row is an assignment, with `*` representing
#'   nonpairing.
#' @param from A character vector; either victims or missing persons. By
#'   default, the column names of `df`. The only time this argument is needed,
#'   if when `df` has other columns in addition, as in output tables of
#'   `dviJoint()`.
#' @param to The column names of the transformed data frame. If missing, the
#'   unique elements of `df` are used. An error is raised if `to` does not
#'   contain all elements of `df` (except `*`).
#'
#' @return A data frame with `nrow(df)` rows and `length(to)` columns.
#'
#' @examples
#' df = example1 |> generatePairings() |> expand.grid.nodup()
#' df
#' swapRoles(df)
#' 
#' # Swap is idempotent
#' stopifnot(identical(swapRoles(swapRoles(df)), df))
#' 
#' @export
swapRoles = function(df, from = NULL, to = NULL) {

  if(is.null(from))
    from = names(df)
  
  # Matrix for speed
  amat = as.matrix(df[from])
  
  if(is.null(to))
    to = setdiff(sort.default(unique.default(amat)), "*")
  
  dims = dim(amat)
  
  # Match
  toExt = c(to, "*")
  idx = match(amat, toExt, nomatch = 0L)
  if(any(idx == 0))
     stop2("Table entry not included in `to`: ", setdiff(amat, toExt))
  idx[idx == length(toExt)] = 0L
  dim(idx) = dims
  
  # Melt to long format
  long = cbind(which(idx > 0, arr.ind = TRUE), 
               val = idx[idx > 0])
  
  # Create result matrix
  new = matrix("*", nrow = dims[1], ncol = length(to), dimnames = list(NULL, to))
  
  # Pivot back to wide
  new[long[, c(1,3)]] = from[long[,2]]
  
  res = as.data.frame(new)
  if(ncol(df) > length(from))
    res = cbind(res, df[!names(df) %in% from])
  res
}
