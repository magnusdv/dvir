#' Joint DVI search
#'
#' _Note_: This is a simplified version of [jointDVI()], purely focused on joint
#' analysis. It also gives more extensive output, including conditional LRs,
#' suitable for incorporation in [dviSolve()].
#'
#' @param dvi A `dviData` object, typically created with [dviData()].
#' @param assignments A data frame containing the assignments to be considered
#'   in the joint analysis. By default, this is automatically generated by
#'   taking all combinations from `dvi$pairings`.
#' @param disableMutations Either TRUE, FALSE (default) or NA. If NA, mutation
#'   modelling is applied only in families where the reference data are
#'   incompatible with the pedigree unless at least one mutation has occurred.
#' @param maxAssign A positive integer. If the number of assignments going into
#'   the joint calculation exceeds this, the function will abort with an
#'   informative error message. Default: 1e5.
#' @param numCores An integer; the number of cores used in parallelisation.
#'   Default: 1.
#' @param cutoff A number; if non-negative, the output table is restricted to
#'   LRs equal to or exceeding this value.
#' @param verbose A logical.
#'
#' @return A data frame. Each row describes an assignment of victims to missing
#'   persons, accompanied with its log likelihood, the LR compared to the null
#'   (i.e., no identifications), and the posterior corresponding to a flat
#'   prior.
#'
#'   The function `compactJointRes()` removes columns without assignments, and
#'   solutions whose LR compared with the top result is below `1/LRthresh`.
#'
#' @examples
#' dviJoint(example2)
#'
#' @importFrom utils setTxtProgressBar txtProgressBar
#' @importFrom parallel makeCluster stopCluster detectCores parLapply
#'   clusterEvalQ clusterExport
#'
#' @export
dviJoint = function(dvi, assignments = NULL, disableMutations = FALSE, 
                    maxAssign = 1e5, numCores = 1, cutoff = 0, verbose = TRUE) {
  
  st = Sys.time()
  
  # Ensure proper dviData object
  dvi = consolidateDVI(dvi)
  
  origVics = vics = names(dvi$pm)
  
  if(verbose)
    print.dviData(dvi)
  
  ### Mutation disabling
  if(any(allowsMutations(dvi$am))) {
    am = dvi$am
    
    if(verbose) 
      cat("\nMutation modelling:\n")
    
    if(isTRUE(disableMutations)) {
      if(verbose) cat(" Disabling mutations in all families\n")
      disableFams = seq_along(am)
    }
    else if(identical(disableMutations, NA)) {
      am.nomut = setMutmod(am, model = NULL)
      badFams = vapply(am.nomut, loglikTotal, FUN.VALUE = 1) == -Inf
      if(verbose) {
        if(any(badFams)) 
          cat("", sum(badFams), "inconsistent families:", trunc(which(badFams)), "\n")
        cat("", sum(!badFams), "consistent families. Disabling mutations in these\n")
      }
      disableFams = which(!badFams)
    }
    else disableFams = NULL
  
    if(length(disableFams)) {
      am[disableFams] = setMutmod(am[disableFams], model = NULL)
    }
    
    # Update DVI object
    dvi$am = am
  }
  
  pm = dvi$pm 
  am = dvi$am
  pairings = dvi$pairings
  
  if(is.null(assignments)) {
    if(verbose) cat("\nCalculating pairing combinations\n")
    # Expand pairings to assignment data frame
    assignments = expand.grid.nodup(pairings, max = maxAssign)
  }
  else {
    if(verbose) cat("\nChecking supplied pairing combinations\n")
    if(!setequal(names(assignments), origVics))
      stop2("Names of `assignments` do not match `pm` names")
    assignments = assignments[origVics]
  }
  
  nAss = nrow(assignments)
  if(nAss == 0)
    stop2("No possible solutions!")
  if(verbose)
    cat("Assignments to consider in the joint analysis:", nAss, "\n\n")
  
  # Convert to list; more handy below
  assignmentList = lapply(1:nAss, function(i) as.character(assignments[i, ]))
  
  # Initial loglikelihoods
  logliks.PM = vapply(pm, loglikTotal, FUN.VALUE = 1)
  logliks.AM = vapply(am, loglikTotal, FUN.VALUE = 1)
  
  loglik0 = sum(logliks.PM) + sum(logliks.AM)
  if(loglik0 == -Inf)
    stop2("Impossible initial data: AM component ", which(logliks.AM == -Inf))
  
  # Parallelise
  if(numCores > 1) {
    
    if(verbose) 
      cat("Using", numCores, "cores\n")
    
    cl = makeCluster(numCores)
    on.exit(stopCluster(cl))
    clusterEvalQ(cl, library(dvir))
    clusterExport(cl, "loglikAssign", envir = environment())

    # Loop through assignments
    loglik = parLapply(cl, assignmentList, function(a) 
      loglikAssign(pm, am, vics, a, loglik0, logliks.PM, logliks.AM))
  }
  else {
    # Setup progress bar
    if(progbar <- verbose && interactive())
      pb = txtProgressBar(min = 0, max = nAss, style = 3)
    
    loglik = lapply(seq_len(nAss), function(i) {
      if(progbar) setTxtProgressBar(pb, i)
      loglikAssign(pm, am, vics, assignmentList[[i]], loglik0, logliks.PM, logliks.AM)
    })
    
    # Close progress bar
    if(progbar) close(pb)
  }
  
  loglik = unlist(loglik)
  
  # Joint LR
  jLR = exp(loglik - loglik0)
  posterior = jLR/sum(jLR) # assumes a flat prior
  
  # Conditional LRs
  cLR = conditionalLR(assignments, jointLR = jLR)
  
  # Collect results
  tab = cbind(assignments, cLR, loglik = loglik, jLR = jLR, posterior = posterior)
  
  # Sort in decreasing likelihood, break ties with grid
  g = assignments
  g[g == "*"] = NA
  tab = tab[do.call(order, g), , drop = FALSE] # first sort assignments alphabetically
  tab = tab[order(round(tab$loglik, 10), decreasing = TRUE), , drop = FALSE]
  
  rownames(tab) = NULL
  
  if(verbose)
    cat("Time used:", format(Sys.time() - st, digits = 3), "\n")
  
  tab
}

conditionalLR = function(assignments, jointLR) {
  
  # Convert to matrix (faster)
  amat = as.matrix(assignments)
  nass = nrow(amat)
  nc = ncol(assignments)
  
  # For each assignment A, and each nontrivial element M of A, we must find 
  # the row of amat in which M is replaced with *, and A is otherwise unchanged.
  # We will store these row numbers in a matrix similar to amat.
  companionRow = matrix(NA_integer_, nrow = nass, ncol = nc)
  
  # The array gymnastics to follow is more convenient when we transpose
  aTrans = t.default(amat)
  
  # Array of copies of aTrans, one layer for each assignment
  arr = rep(aTrans, nass)
  dim(arr) = c(nc, nass, nass)  # arr[,,1] = arr[,,2] = ...
  
  # Array where layer i contains copies of assignment i 
  aLayers = lapply(1:nass, function(i) rep(aTrans[,i], nass)) |> unlist(use.names = FALSE)
  dim(aLayers) = dim(arr)
  
  # All changes ...
  diff = arr != aLayers
  
  # ... with exactly 1 diff in column
  diff1 = diff & rep(colSums(diff, 2) == 1, each = nc)
  
  # ... and the change is into *
  toStar = diff1 & arr == "*"
  
  # Indices of T's
  idx = which(toStar, arr.ind = TRUE)
  
  # Interpretation of columns of idx (i.e., dim order in toStar)
  # 1 : column of amat
  # 2 : row of amat with a change to * in this col (This is what we want!)
  # 3 : row of amat whose assignment we are comparing with 
  # Hence:
  companionRow[idx[, c(3,1)]] = idx[,2]
  
  # Conditional LRs, returned as matrix corresponding to amat
  cLR = jointLR / jointLR[companionRow]
  dim(cLR) = dim(amat)
  colnames(cLR) = paste0("cLR_", colnames(amat))
  
  as.data.frame(cLR)
}


