% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/global.R
\name{global}
\alias{global}
\alias{checkDVI}
\title{Search for best DVI solution and check input}
\usage{
global(
  from,
  to,
  ids.to,
  moves = NULL,
  limit = 0,
  numCores = 1,
  check = TRUE,
  verbose = FALSE
)
}
\arguments{
\item{from}{A list of singletons.}

\item{to}{A list of pedigrees.}

\item{ids.to}{Character vector with names of missing persons.}

\item{moves}{List of length equal length of `from` with possible marginal moves.}

\item{limit}{Double. Only moves with LR above limit are kept.}

\item{numCores}{Integer. The number of cores used in parallelisation. Default: 1.}

\item{check}{A logical, indicating if the input data should be checked for consistency.}

\item{verbose}{A logical.}
}
\value{
A data frame. Each row describes an a priori possible move. The log likelihood, 
the LR with the null hypothesis of no moves in the numerator, and the posterior corresponding 
to a flat prior, i.e., the inverse of the number of assignments
}
\description{
Victims are given as a list of singletons and references as list of pedigrees.
Based on a specification of moves for each victim, if any, all possible assignments 
are evaluated and solutions ranked according to the likelihood..
}
\details{
This is currently a brute force approach, all possibilities are evaluated
}
\examples{
\donttest{
library(forrel)

### Example 1 ###

# Attributes of a single marker
locAttr = list(name = "m", alleles = 1:3, afreq = c(1, 1, 1)/3)

# PM data (victims: 6 males, 1 female)
vics = paste0("V", 1:7)
sex = c(1,1,1,1,1,1,2)
df = data.frame(famid = vics, id = vics, fid = 0, mid = 0, sex = sex,
                m = c("1/1", "2/2", "1/1", "1/1", "2/2", "2/2", "2/2"))
from = as.ped(df, locusAttributes = locAttr)

# AM data (families)
MPs = c("MP1", "MP2", "MP3")
to = nuclearPed(3, father = "R1", mother = "R2", children = MPs)
m = marker(to, "R1" = "1/1", "R2" = "1/1", name = "m")
to = setMarkers(to, m, locusAttributes = locAttr)

# Plot
plotPedList(list(from, to), marker = 1, col = list(red = MPs),
            titles = c("PM data", "AM data"))

# Analysis considering all sex-consistent assignments
res1 = global(from, to, MPs, moves = NULL, limit = -1, verbose = FALSE)

# Quicker alternative: Consider only the three best moves for each victim
moves = generateMoves(from, to, MPs) # generate all sex-consistent assignments
moves2 = marginal(from, to,  MPs, moves, limit = -1, nkeep = 3)
res2 = global(from, to, MPs, moves2[[1]], limit = -1, verbose = FALSE)

# Further reduction: Only consider victims V1, V3 and V4
moves2 = moves[c("V1", "V3", "V4")]
res = global(from, to, MPs, moves2, limit = -1)

### Example 2 ###
# Checked against; http://familias.name/BookKEP/globalExample2.fam

# Single locus with 10 alleles
loc = list(alleles = 1:10)

# Victims: 3 males, 1 female
vics = paste0("V", 1:4)
sex = c(1, 1, 2, 1)
df = data.frame(famid = vics, id = vics, fid = 0, mid = 0, sex = sex,
                m1 = c("1/1", "1/2", "3/4", "3/4"))
from = as.ped(df, locusAttributes = loc)

# Reference families: 4 missing persons; 2 genotyped relatives
fam1 = nuclearPed(1, father = "MP1", child = "MP2", mother ="R1")
fam2 = halfSibPed(sex1 = 1, sex2 = 2)
fam2 = relabel(fam2, c("MO2", "R2", "MO3", "MP3", "MP4"))
data = data.frame(m1 = c(R1 = "2/2", R2 = "3/3"))
to = setMarkers(list(fam1, fam2), alleleMatrix = data, locusAttributes = loc)

# Generate sex-consistent moves
ids.to = c("MP1", "MP2", "MP3", "MP4") # user specified
moves = generateMoves(from, to, ids.to)

# Rank according to likelihood
res1 = global(from, to, ids.to, moves = moves, limit = 0, verbose = TRUE)
resmarg = marginal(from, to, ids.to, moves = moves, limit = 0,
             verbose = TRUE, nkeep = 2)
res2 = global(from, to, ids.to, moves = resmarg[[1]], limit = 0, verbose = TRUE)

# From fam file
x = readFam("http://familias.name/BookKEP/globalExample2.fam")
from = x$families[1:4]
to = x$families[5:6]
plotPedList(list(from, to))
res3 = global(from, to, ids.to, moves = moves, limit = 0, verbose = TRUE)

stopifnot(identical(res1, res3))

}

}
\seealso{
`marginal`.
}
