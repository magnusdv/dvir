---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, echo = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  cache.path = "README_cache/"
)
```


# The dvir (Disaster Victim Identification) library

We assume DNA profiles are available from victim samples (post mortem, pm data) and 
reference families (ante mortem, am data) with missing persons (typically labelled M1, M2,...). 
<!-- There may be  -->
<!-- several samples from the same victim, potentially of low quality leading to *drop-outs*. -->
The problem is to identify the missing persons, the M-s. Some (or all) victims may not be 
among the M-s. Similarly, there may be M-s not in the list of victims.
A search strategy
is implemented.
Results are sorted according to the likelihood and likelihood ratios LR-s (compared to the null
likelihood) are reported. 
The number of assignments may be prohibitively large and for this reason alternatives to
an exhaustive search are implemented.

## Installation

To get the latest version, install from GitHub as follows:

```{r, eval = FALSE}
 # First install devtools if needed
if(!require(devtools)) install.packages("devtools")

# Install dvir from GitHub
devtools::install_github("thoree/dvir")
```
The implementation relies heavily on 
the `ped suite` of R-libraries, in particular `forrel` and `pedmut`.

## Load libraries

We start by loading **dvir**. We also load **pedtools** for creating and plotting pedigrees:
```{r}
library(dvir)
library(pedtools)
```

## Example 1

We consider the following example

```{r}
# Single marker with three equifrequent alleles
locAttr = list(name = "m", alleles = 1:3, afreq = c(1, 1, 1)/3)
# pm data. 7 victims named "V1", ..."V7"
n = 7
missing = paste0("V", 1:n)
sex = c(rep(1, n-1), 2)
df = data.frame(famid = missing, id = missing, fid = 0, mid = 0, sex = sex,
                m = c("1/1", "2/2", "1/1", "1/1", "2/2", "2/2", "2/2"))
pm = as.ped(df, locusAttributes = locAttr)

# am data. 
# Reference families, here one, with missing persons M1, M2, and M3
# and references "R1" and "R2"
MPs = c("M1", "M2", "M3")
am = nuclearPed(3, father = "R1", mother = "R2", children = MPs)
m = marker(am, "R1" = "1/1", "R2" = "1/1", name = "m")
am = setMarkers(am, m, locusAttributes = locAttr)
```

The DVI problem is summarised by the below figure:

```{r ex1-ped, fig.height = 3, fig.width = 7}
# Plot both
plotPedList(list(pm, am), marker = 1, 
            hatched = typedMembers, 
            col = list(red = MPs), 
            titles = c("pm data. 7 victims", "am data. 3 M-s"))
```

We do not consider mutations or other artefacts in this example. We assume that copies of victim samples have been identified and merged. Without extra information, like age data,
there are six symmetric solutions. If the ages are known, for instance age(V1) > age(V2) > age(V3), there may a unique solution.
Recall the convention that individuals are ordered left to right in the pedigree based on age.

### The number of assignments

The number of possible assignments is:

```{r}
ncomb(nVfemales = 1, nMPfemales = 0, nVmales = 6, nMPmales = 3)
```

The complete list of these assignments is generated as follows:

```{r} 
moves = generateMoves(pm, am, MPs)
a = expand.grid.nodup(moves)
head(a)
```

### The search

The following search ranks all possible solutions by their likelihood. The ten best solutions are shown.
```{r}
res = jointDVI(pm, am, MPs, moves = NULL, limit = -1, verbose = F)
res[1:10, ]
```


## Example 2

We next consider a larger dataset

```{r}
data(grave)
pm = grave$pm
am = grave$am
missing = grave$missing
```

The family `am` has 8 missing persons, labelled MP1-MP8, and 5 genotyped family members, labelled R1-R5. The pedigree is shown below.

```{r ex2-ped}
refs = paste0("R", 1:5)
missing = paste0("MP", 1:8)
plot(am, title = "AM data", labs = c(refs, missing), hatched = c(refs, missing), 
     col = list(red = refs, blue = missing))
```

The list of singletons in `pm` contains female victims V1, V3, V4, V5, V6,
and male victims V2, V7, V8. The *a priori* possible number of assignments,
ignoring symmetries, is

```{r}
ncomb(nVfemales = 5, nMPfemales = 5, nVmales = 3, nMPmales = 3)
```

We first do a single search 

```{r}
m = pairwiseLR(pm, am, missing)
print(m$LRmatrix,3)
```





We next perform the search:
```{r}
res1 = jointDVI(pm, am, missing, limit = 0, numCores = 4)
head(res1)
```




