---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, echo = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  cache.path = "README_cache/"
)
```


# Disaster Victim Identification using library **dvir**

## Installation

To get the latest version, install from GitHub as follows:

```{r, eval = FALSE}
 # First install devtools if needed
if(!require(devtools)) install.packages("devtools")

# Install dvir from GitHub
devtools::install_github("thoree/dvir")
```

The implementation relies heavily on 
the `ped suite` of R-libraries, in particular **forrel** and **pedmut**.

## Tutorial example

The library **dvir** deals with computational aspects of DNA based disaster victim identification (DVI).
We use  a toy example from the preprint
https://www.researchsquare.com/article/rs-296414/v1 of the paper
"Joint DNA-based disaster victim identification" by Vigeland and Egeland
to illustrate DVI problems. The post mortem (PM) data in the below figure
consists of 3 victim samples to be matched against 3 missing persons (red) belonging to two different families.
The AM data contains profiles from the reference individuals 
R1 and R2 (blue), one from each family. 
The hatched individuals are typed with a single marker having 10 equifrequent alleles denoted 1, 2,..., 10.

```{r, example, echo = FALSE, fig.height = 4, fig.width = 4, out.width = "40%"}
library(dvir)
library(pedtools)
pm = example2$pm
am = example2$am
missing = example2$missing
refs = c("R1", "R2")
plotPedList(list(pm, am), col = list(red = missing, blue = refs), shaded = typedMembers,
            labs = c(refs, labels(pm), missing), marker = "L1", cex = 1.2, margins = c(1,1.2,1,1.2),
            frames = F, titles = c("PM data", "AM data"))
```

There are 14 possible solutions or _assignments_ and these are listed next:

```{r, echo = F}
am2 = pedprobr::setMutationModel(am, model = "proportional", rate = 0.005)
pm2 = pedprobr::setMutationModel(pm, model = "proportional", rate = 0.005)
jointDVI(pm2,am2, missing, disableMutations = FALSE, verbose = F)[,1:3]
```

The first line gives the assignment where V1 = M1, V2 = M2 and V3 = M3
while line 10 shows the  _null model_ corresponding to no victims identified.
For each assignment _a_ we can calculate the likelihood, denoted _L(a)_. The null
likelihood is _L0_.


There are two main goals:

1) Rank the assignments according to how likely they are. Calculate the LR comparing each assignment
_a_ to the null model., i.e., _L(a)/L0_ . 
The assignments in the above table are sorted according to decreasing LR as we will see later. 

2) Find the posterior pairing and non pairing probabilities. These are defined as

_P(Vi = Mj |_ data) and _P(Vi = '*' |_ data) for _i, j = 1, 2, 3_. 

We next describe how to do the calculations to meet goals 1 and 2.


### The data

The data is available within the library  and can be extracted as follows


```{r}
library(dvir)
pm = example2$pm
am = example2$am
missing = example2$missing
```

Alternatively, we can do the input from scratch as shown below

```{r}
library(pedtools)
loc = list(name = "L1", 
           alleles = 1:10,
           afreq = rep(1/10,10))

# PM data
victims = paste0("V", 1:3)

pm.df = data.frame(famid = victims, id = victims,
                   fid = 0, mid = 0, sex = c(1, 1, 2),
                   L1 = c("1/1", "1/2", "3/4"))
pm = as.ped(pm.df, locusAttributes = loc)

# AM data
am1 = nuclearPed(father = "M1", mother = "R1", child = "M2")
L1 = marker(am1, "R1" = "2/2", name = "L1", alleles = loc$alleles, afreq = loc$afreq)
am1 = setMarkers(am1, L1)

am2 = nuclearPed(father = "R2", mother = "MO2", child = "M3", sex = 2)
L1 = marker(am2, "R2" = "3/3", name = "L1", alleles = loc$alleles, afreq = loc$afreq)
am2 = setMarkers(am2, L1)

am = list(am1, am2)

missing = c("M1", "M2", "M3")
```

### Calculation

The required code for items 1) and 2) above are simply

```{r}
jointRes = jointDVI(pm, am, missing, verbose = FALSE)
jointRes
```

and

```{r}
Bmarginal(jointRes, missing, prior = NULL)
````

In both cases we have used a default flat prior assigning equal prior
probabilities to all assignments. The prior does not influence the LR.
The most likely joint solution V1 = M1, V2 = M2, V3 = M3 gets an LR of 250 compared
to the null model. From the lower table we see that the posterior
pairing probabilities are 

_P(V1 = M1_ | data) = 0.88, _P(V2 = M2_ | data) =0.95 and _P(V3 = M2_ |data) =0.83.
